{
  "name": "sandal",
  "description": "Javascript inversion of control container",
  "version": "1.0.1",
  "main": "sandal",
  "author": {
    "name": "Marcus Berner",
    "email": "marcus@burner.se"
  },
  "devDependencies": {
    "tap": "~0.4.4"
  },
  "scripts": {
    "test": "./node_modules/.bin/tap ./test"
  },
  "keywords": [
    "sandal",
    "ioc",
    "inversion of control",
    "dependency injection"
  ],
  "license": {
    "type": "MIT",
    "url": "https://github.com/marcusberner/sandal/raw/master/LICENSE"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/marcusberner/sandal"
  },
  "engines": {
    "node": "*"
  },
  "readme": "# Sandal\n\nSandal is a javascript inversion of control container\n\n[![Build Status](https://travis-ci.org/marcusberner/sandal.png?branch=master)](https://travis-ci.org/marcusberner/sandal)\n\n[![NPM](https://nodei.co/npm/sandal.png?downloads=true)](https://nodei.co/npm/sandal/)\n\n## Installation\n\n    $ npm install sandal\n\n## Usage\n\nA sandal container can be used to register and resolve objects.\n\n### Create a container\n\n```js\nvar Sandal = require('sandal');\nvar sandal = new Sandal();\n```\n\n### Register object\n\nResolving an item registered with `.object()` will always return the same object that was registered.\n\nThe name of an object, service or factory can not be `sandal` or `done`, since resolving sandal will return the container and done is reserved for the done callback for services and factories.\n\nRegistering is a synchronous operation and will throw an error if failing.\n\n```js\nsandal.object('myObject', 'any object');\n```\n\n### Register service\n\nResolving a service registered with `.service()` will call the registered object as a constructor and return the resulting object. The arguments to the constructor will be resolved based on name before the constructor is called and injected. Thus all arguments must be registered.\n\nA service has a singleton behaviour by default, meaning that the constructor will only be called once and the same resulting object will be resolved every time. By providing a transient flag as a third argument the constructor will be called every time the service is resolved.\n\nIf the constructor requires some asynchronous tasks to be completed before the resulting object is ready to use, a done callback named `done` can be taken as a constructor argument. This will inject a callback that has to be called before the service is resolved. The done callback accepts an error. If an error is provided, that will result in an error when resolving the service or any factory or service dependent on the service.\n\n```js\nvar MyService = function (dependency1) {\n};\nMyService.prototype.doStuff = function () {};\n\nvar MyAsyncService = function (dependency1, done) {\n    dependency1.doSomeAsyncInit(done);\n};\n\nvar MyTransientService = function (dependency1, done) {\n    dependency1.doSomeAsyncInit(done);\n};\n\nsandal.service('myService', MyService);\nsandal.service('myAsyncService', MyAsyncService);\nsandal.service('myTransientService', MyTransientService, true);\n```\n\n### Register factory\n\nResolving a factory registered with `.factory()` will return the value returned by the factory function. Just like a service the default behaviour is singleton but can be made transient by providing the transient flag.\n\nA factory that requires some asynchronous task to be completed should take a `done` callback just like a service. If a factory takes a done callback, the second argument of the done callback will be the resolved object instead of the return value of the factory function.\n\n```js\nvar MyFactory = function (dependency1) {\n    return 'some value';\n};\n\nvar MyAsyncFactory = function (dependency1, done) {\n    dependency1.doSomeAsyncInit(function (err) {\n        done(err, 'some value');\n    });\n};\n\nvar MyTransientFactory = function (dependency1) {\n    return 'some value';\n};\n\nsandal.factory('myFactory', MyFactory);\nsandal.factory('myAsyncFactory', MyAsyncFactory);\nsandal.factory('myTransientFactory', MyTransientFactory, true);\n```\n\n### Resolve\n\nResolving can be done by providing a function to `.resolve()`. The first argument of the function will be any error from resolving. The names or the arguments following the error will be matched to the registered names and the function will be called when all requested objects are resolved.\n\nThe name/names or the objects to resolve can also be provided as strings. This will inject them into the provided function in the same order they were specified following the error. When the names are provided as strings the argument names of the callback doesn't matter.\n\nResolving a service or factory will always resolve all dependencies recursively.\n\nResolving is an asynchronous operation if any of the resolved dependencies are asynchronous.\n\n```js\nsandal.resolve(function (err, myObject, myService, myFactory) {\n});\n\nsandal.resolve('myObject', function (err, o) {\n});\n\nsandal.resolve(['myObject', 'myService', 'myFactory'], function (err, o, s, f) {\n});\n```\n\n### Remove\n\nTrying to register using a name that is already registered will result in throw an error. To replace a registered component it has to be removed first.\n\nClearing all registered objects can be done by calling `.clear()`.\n\nRemoving one or a set of objects can be done by providing the names to `.remove()`.\n\nClearing and removing are synchronous operations.\n\n```js\nsandal.clear();\nsandal.remove('myObject');\nsandal.remove(['myObject', 'myService', 'myFactory']);\n```\n\n### Chaining\n\nAll sandal operations can be chained.\n\n```js\nsandal.factory('myFactory', MyFactory).resolve(function (err, myFactory) {\n});\n```",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/marcusberner/sandal/issues"
  },
  "_id": "sandal@1.0.1",
  "_from": "sandal@~1.0.1"
}
